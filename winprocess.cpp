#include "winprocess.h"
#include "charset.h"

unsigned char shellcode_loaddll_32[8 + 261*2 + 30] = { 0x60, 0x6A, 0x00, 
0xE8, 0x0a, 0x02, 0x00, 0x00,

0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00 ,
0x00, 0x00, 0x00, 0x00, 0x00 ,

0x68, 0x00, 0x00, 0x0a, 0x02,
0x8D, 0x44, 0x24, 0x08,
0x50, 
0x8D, 0x4c, 0x24, 0x04,
0x51,
0x50, 0x90,
0x6A, 0x00, 
0xB8, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xD0, 
0x58, 0x58, 0x58,
0x61
};

unsigned char shellcode_loaddll_64[19 + 261*2 + 56] = {
	0x50, 0x51, 0x52, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41, 0x53, 0x9C,
	0x6A, 0x00,
	0xE8, 0x0a, 0x02, 0x00, 0x00,

	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00 ,
	0x00, 0x00, 0x00, 0x00, 0x00 ,
	0x68, 0x00, 0x00, 0x0a, 0x02,
	0x48, 0xC7, 0xC1, 0x00, 0x00, 0x00, 0x00,
	0x48, 0x8D, 0x54, 0x24, 0x10,
	0x4C, 0x8D, 0x04, 0x24,
	0x49, 0x89, 0xD1,
	0x48, 0x83, 0xec, 0x20,
	0x48, 0xB8, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11,
	0xff, 0xd0,
	0x48, 0x83, 0xC4, 0x38,
	0x9D, 0x41, 0x5B, 0x41, 0x5A, 0x41, 0x59, 0x41, 0x58, 0x5A, 0x59, 0x58

};

CWinProcess::~CWinProcess()
{
	if (m_hProcess)
		CloseHandle(m_hProcess);
	if (m_hProcess)
		CloseHandle(m_hThread);
}

CWinProcess::CWinProcess() : m_hProcess(0),
							 m_hThread(0)
{

}

CWinProcess::CWinProcess(unsigned pid)
{
	m_hThread = 0;
	m_hProcess = ::OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
		FALSE, pid);
	if (!m_hProcess)
		throw "OpenProcess Error";
}

bool CWinProcess::start(const std::string &app,
	const std::string &workDir,
	const std::string &paramters)
{
	bool success = false;
	charset::u16str u16Paramters = charset::u8ToU16Str(paramters);
	charset::u16str u16App = charset::u8ToU16Str(app);
	charset::u16str u16WorkDir = charset::u8ToU16Str(workDir);
	std::vector<wchar_t> commandLine(u16Paramters.begin(), u16Paramters.end());
	commandLine.push_back(0);

	STARTUPINFOW info = { sizeof(STARTUPINFOW) };
	PROCESS_INFORMATION procInfo = { 0 };
	success = !!::CreateProcessW(u16App.empty() ? nullptr : u16App.c_str(),
		commandLine.size() == 1 ? nullptr : commandLine.data(), NULL,
		NULL, FALSE,
		CREATE_SUSPENDED, NULL,
		u16WorkDir.empty() ? nullptr : u16WorkDir.c_str(),
		&info, &procInfo);
	if (!success)
	{
		return false;
	}
	m_hProcess = procInfo.hProcess;
	m_hThread = procInfo.hThread;
	if (!m_hProcess)
		return false;

	return success;
}

bool CWinProcess::resume()
{
	return -1 != ResumeThread(m_hThread);
}

bool CWinProcess::readP(void *address, std::string &readBuffer)
{
	std::vector<unsigned char> buffer(readBuffer.size());
	bool success = false;
	SIZE_T nByteRead = 0;
	if (::ReadProcessMemory(m_hProcess,
		address,
		buffer.data(),
		buffer.size(),
		&nByteRead) && nByteRead == buffer.size())
	{
		readBuffer.assign(buffer.begin(), buffer.end());
		return true;
	}
	return success;
}

unsigned CWinProcess::protectP(void *address, size_t sz, unsigned flag)
{
	DWORD dwOldProtect = 0;
	if (0 != VirtualProtectEx(m_hProcess,
		address,
		sz,
		PAGE_EXECUTE_READWRITE,
		&dwOldProtect)
		)
	{
		return dwOldProtect;
	}
	return 0;
}

bool CWinProcess::writeP(void *address, std::string &writeBuffer)
{
	bool result = false;
	SIZE_T nByteWrite = 0;
	DWORD dwOldProtect = protectP(
		address,
		writeBuffer.size(),
		PAGE_EXECUTE_READWRITE);
	if (dwOldProtect == 0)
		return result;

	if (::WriteProcessMemory(m_hProcess,
		address,
		writeBuffer.data(),
		writeBuffer.size(),
		&nByteWrite) && nByteWrite == writeBuffer.size()
		)
		result = true;

	result = !!protectP(
		address,
		writeBuffer.size(),
		dwOldProtect);

	return result;
}

void* CWinProcess::allocP(size_t sz, unsigned flag)
{
	void *p =
	VirtualAllocEx(m_hProcess, 
		nullptr, 
		sz, 
		MEM_COMMIT | MEM_RESERVE, 
		flag);
	return p;
}

bool CWinProcess::freeP(void *p)
{
	return 0 != VirtualFreeEx(m_hProcess, p, 0, MEM_RELEASE);
}

void* CWinProcess::getEP()
{
	void *entryPoint = nullptr;
	CONTEXT ctx;
	ctx.ContextFlags = CONTEXT_ALL;
	::GetThreadContext(m_hThread, &ctx);

#ifdef _M_AMD64
	entryPoint = reinterpret_cast<void *>(ctx.Rcx);
#else
	entryPoint = reinterpret_cast<void *>(ctx.Eax);
#endif
	
	return entryPoint;
}

void* CWinProcess::getBase()
{
	void *ep = getEP();
	if (nullptr == ep)
		return nullptr;

	MEMORY_BASIC_INFORMATION mbi;
	if (::VirtualQueryEx(m_hProcess, ep, &mbi, sizeof(mbi)) != sizeof(mbi))
	{
		return nullptr;
	}
	if (!(mbi.Type & MEM_IMAGE))
		return nullptr;

	return mbi.AllocationBase;
}

void* CWinProcess::findMiddleSpace(size_t sz)
{
	void *base = getBase();
	if (!base)
		return nullptr;
	
	std::string dosBuffer(sizeof(IMAGE_DOS_HEADER), 0);
	if (!readP(base, dosBuffer))
		return nullptr;

	const PIMAGE_DOS_HEADER pDos = (const PIMAGE_DOS_HEADER)dosBuffer.data();
	if ((WORD)'ZM' != pDos->e_magic)
			return nullptr;

	void *address = (void *)((intptr_t)base + pDos->e_lfanew);
	std::string ntBuffer(sizeof(IMAGE_NT_HEADERS), 0);
	if (!readP(address, ntBuffer))
		return nullptr;
	
	const PIMAGE_NT_HEADERS pNt = (const PIMAGE_NT_HEADERS)ntBuffer.data();
	if ((DWORD)'EP' != pNt->Signature)
		return nullptr;

#define ALIGN_UP(l, a) (((l + a - 1)/a)*a)
	DWORD dwOffset = pNt->FileHeader.NumberOfSections * sizeof(IMAGE_SECTION_HEADER) + sizeof(IMAGE_NT_HEADERS) + pDos->e_lfanew;
	dwOffset = (dwOffset + 15 ) & 0xfffffff0;
	DWORD dwSize = ALIGN_UP(pNt->OptionalHeader.SizeOfHeaders, pNt->OptionalHeader.SectionAlignment);

	address = (void *)((intptr_t)base + dwOffset);
	size_t nLen = dwSize - dwOffset;
	std::string buffer(nLen, 0);
	if (!readP(address, buffer))
		return nullptr;

	std::string jmp(sz, 0);
	size_t pos = buffer.find(jmp);
	if (pos == std::string::npos)
		return nullptr;
	
	return (void *)((intptr_t)address + pos);
}

std::string CWinProcess::getShellCode(const std::string &dll)
{
	void *rip = nullptr;
	CONTEXT ctx;
	ctx.ContextFlags = CONTEXT_ALL;
	::GetThreadContext(m_hThread, &ctx);
#ifdef _M_AMD64
	rip = reinterpret_cast<void *>(ctx.Rip);
#else
	rip = reinterpret_cast<void *>(ctx.Eip);
#endif
	MEMORY_BASIC_INFORMATION mbi;
	if (::VirtualQueryEx(m_hProcess, rip, &mbi, sizeof(mbi)) != sizeof(mbi))
	{
		return "";
	}
	if (!(mbi.Type & MEM_IMAGE))
		return "";

	HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
	void *pfnLoadDll = GetProcAddress(hNtdll, "LdrLoadDll");
	ptrdiff_t offset = (intptr_t)pfnLoadDll - (intptr_t)hNtdll;
	void *remoteLoadDll = (void *)((intptr_t)mbi.AllocationBase + offset);
	charset::u16str u16Dll;
	charset::u8ToU16Str(dll, u16Dll);
#if  defined(_WIN64) || defined(__x86_64__)
	std::vector<unsigned char> shellcode(shellcode_loaddll_64, shellcode_loaddll_64 + sizeof(shellcode_loaddll_64));
	memcpy((char *)shellcode.data() + 19, u16Dll.data(), (u16Dll.length() + 1) * 2);
	*(USHORT *)(shellcode.data() + 19 + 261 * 2 + 1) = (USHORT)u16Dll.size() * 2;
	*(void **)(shellcode.data() + (shellcode.size() - 26)) = remoteLoadDll;
#else
	std::vector<unsigned char> shellcode(shellcode_loaddll_32, shellcode_loaddll_32 + sizeof(shellcode_loaddll_32));
	memcpy((char *)shellcode.data() + 8, u16Dll.data(), (u16Dll.length() + 1)*2);
	*(USHORT *)(shellcode.data() + 8 + 261 * 2 + 1) = (USHORT)u16Dll.size()*2;
	*(void **)(shellcode.data() + (shellcode.size() - 10)) = remoteLoadDll;
#endif
	
	return std::string(shellcode.begin(), shellcode.end());
}